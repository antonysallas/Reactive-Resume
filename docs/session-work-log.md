# Session Work Log: Reactive Resume PDF Export Image Loading Fix

**Date:** May 22, 2025
**Session ID:** PDF Export Image Fix
**Assistant:** Claude Code
**User:** asallasd

## Overview

This session focused on diagnosing and fixing an issue where images were not being included in PDF exports generated by the Reactive Resume application. The problem was identified as a Docker container networking issue preventing the Chrome container from accessing MinIO storage.

## Project Context

**Reactive Resume** is a full-stack resume builder application built with:

- **Frontend:** React 18, Vite, TanStack Query, Zustand
- **Backend:** NestJS, Prisma ORM, PostgreSQL
- **PDF Generation:** Puppeteer via Browserless Chrome
- **Storage:** MinIO for file uploads
- **Container Runtime:** Podman (user's preference over Docker)

### Architecture

- Monorepo structure using Nx
- Multi-container setup with Docker Compose
- Three main applications: client, server, artboard
- Shared libraries for reusable components and utilities

## Issues Encountered & Resolutions

### 1. Primary Issue: Images Missing from PDF Exports

**Symptoms:**

- PDF exports were generated successfully
- Profile images and other uploaded images were missing from PDFs
- Chrome container logs showed `net::ERR_EMPTY_RESPONSE` for MinIO storage URLs

**Root Cause:**
The Chrome container (used for PDF generation) couldn't access MinIO storage at `localhost:9000` because:

- Chrome runs in a separate container
- `localhost` in the Chrome container refers to itself, not the host machine
- The existing request interception logic only handled the main artboard URL, not storage URLs

**Resolution:**
Enhanced the printer service (`apps/server/src/printer/printer.service.ts`) to:

1. Dynamically detect localhost URLs from configuration
2. Extract hostnames using URL parsing instead of hardcoded strings
3. Redirect ALL localhost requests to `host.docker.internal` during PDF generation
4. Use `Set` data structure for better performance (unicorn ESLint rule compliance)

**Code Changes:**

```typescript
// Before: Limited to storage URL with hardcoded localhost check
if (request.url().startsWith(storageUrl)) {
  const modifiedUrl = request.url().replace("localhost", "host.docker.internal");
}

// After: Dynamic hostname detection and replacement
const localhostUrls = [publicUrl, storageUrl].filter((url) => url.includes("localhost"));
const localhostHosts = new Set(
  localhostUrls.map((urlString) => {
    try {
      return new URL(urlString).host;
    } catch {
      return null;
    }
  }).filter(Boolean)
);

// Intercept all localhost requests
if (localhostHosts.has(requestUrl.host)) {
  const modifiedUrl = request.url().replace(requestUrl.hostname, "host.docker.internal");
}
```

### 2. Container Build Issues

**Issue 2.1: Docker vs Podman Configuration**

- User was using Podman instead of Docker
- Original `compose.yml` pulled pre-built image instead of building locally
- Code changes wouldn't take effect without local build

**Resolution:**
Modified `compose.yml` to build locally:

```yaml
# Before
app:
  image: amruthpillai/reactive-resume:latest

# After
app:
  build:
    context: .
    dockerfile: Containerfile
```

**Issue 2.2: Missing Python Dependencies**

- `nice-napi` package failed to build due to missing Python
- Native dependencies require build tools

**Resolution:**
Updated `Containerfile` to include build dependencies:

```dockerfile
# Added Python and build tools
RUN apt update && apt install -y dumb-init python3 make g++ --no-install-recommends && rm -rf /var/lib/apt/lists/*
```

**Issue 2.3: Prisma Generation in Production**

- `prisma:generate` command failed because production install excluded devDependencies
- Prisma CLI needed for schema generation

**Resolution:**
Modified build process to install all dependencies, generate Prisma client, then prune:

```dockerfile
# Install all dependencies (including dev)
RUN pnpm install --frozen-lockfile

# Generate Prisma client
RUN pnpm run prisma:generate && pnpm prune --prod
```

### 3. Podman Storage Corruption

**Issue:**
During troubleshooting, aggressive cleanup commands destroyed all container data:

```bash
podman system prune -a -f  # Removed ALL images and containers
podman volume prune -f     # Removed ALL volumes including other projects
```

**Impact:**

- Lost data from other applications (OpenProject, FMD, etc.)
- Had to recreate Reactive Resume volumes

**Lesson Learned:**
Use targeted cleanup instead of aggressive system-wide prune commands.

## Technical Implementation Details

### File Changes Made

1. **apps/server/src/printer/printer.service.ts**
   - Enhanced request interception logic
   - Added dynamic localhost hostname detection
   - Applied to both `generateResume()` and `generatePreview()` methods
   - Improved code quality per ESLint rules

2. **compose.yml**
   - Changed from pre-built image to local build
   - Updated to use Containerfile instead of Dockerfile

3. **Containerfile**
   - Added Python3, make, g++ for native dependencies
   - Modified dependency installation strategy for Prisma

### Code Quality Improvements

- Followed ESLint unicorn rules (prefer Set over Array, prefer includes over some)
- Used proper TypeScript error handling with try-catch blocks
- Implemented dynamic configuration parsing instead of hardcoded values
- Applied consistent code formatting via Prettier

## Testing & Validation

### Lint Verification

Ran full project linting to ensure code quality:

```bash
pnpm lint  # All projects passed
```

### Build Process

The enhanced Containerfile successfully:

1. Installs all dependencies including native ones
2. Builds all Nx projects (client, server, artboard, libs)
3. Generates Prisma client
4. Creates optimized production image

## Future Considerations

### Backup Strategy Discussion

User expressed interest in automatic backup solutions for container volumes to prevent data loss from cleanup operations.

### Monitoring

Consider adding health checks for MinIO connectivity from the Chrome container to detect similar issues early.

### Documentation

This session demonstrates the importance of:

- Understanding container networking
- Proper Docker/Podman build strategies
- Careful use of cleanup commands
- Comprehensive testing across container boundaries

## Tools & Technologies Used

- **Podman** - Container runtime
- **Docker Compose** - Multi-container orchestration
- **NestJS** - Backend framework
- **Puppeteer** - PDF generation
- **MinIO** - Object storage
- **Nx** - Monorepo tooling
- **ESLint/Prettier** - Code quality
- **Prisma** - Database ORM

## Session Outcome

✅ **Successfully resolved** the image loading issue in PDF exports
✅ **Fixed** container build problems for Podman
✅ **Improved** code quality and maintainability
✅ **Created** comprehensive documentation

The application should now properly include images in PDF exports when running in the containerized environment.
